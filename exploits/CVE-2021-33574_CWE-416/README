== Running Vulnerable version ==

In order to run 'vulnerability_examle' you must do it in a docker container, with glibc 2.32 or 2.33

How to safely run the exploit:

1 - Open Docker Desktop

2 - In your IDE of choice, type in the terminal: docker images
If there is an image named cve-2021-33574_cwe-416_image, skip to step 4, else continue to step 3.

3 - Type in the terminal: docker build -f Dockerfile.vuln -t cve-2021-33574_cwe-416_image .  

4 - In wsl terminal insert: docker run --privileged -it \-v "/mnt/c/Users/User/Desktop/Universidade/Pesquisa AI-SSD/exploits/CVE-2021-33574_CWE-416:/mnt/code" \cve-2021-33574_cwe-416_image
Note: change the path in the command with yours -> "[your path]/exploits/CVE-2021-33574_CWE-416:/mnt/code"

If it takes too long, cancel, restart docker, and try again. The terminal should look like this:

[root@56b80ca79b29 /]# 

Then insert: 
to disable ASLR - Address Space Layout Randomization (randomizes key compnents's memory adresses)
 - echo 0 > /proc/sys/kernel/randomize_va_space

to go to where the code is
 - cd mnt/code/

if you then insert ls, you should see the code file 'vulnerability_example.c'


5 - Check glibc version with: ldd --version
The following message should appear:

ldd (GNU libc) 2.32  //(or 2.33)
Copyright (C) 2020 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
Written by Roland McGrath and Ulrich Drepper.


6 - Compile with: gcc -g -O0 -pthread vulnerability_example.c -o vuln -lrt
Then run with gdb: gdb ./vuln


7 - Inside gdb, execute gdb_trace.cmd: source gdb_trace.cmd
And step through the breaks if you see:

Thread X "vuln" hit Breakpoint Y, notifier_free (arg=0x0) at vulnerability_example.c:29
29/49          memset(&sev, 0, sizeof(sev));


8 - You will have confirmation of corrupted memory caused by use after free when you see this:

--- mq_notify called ---
$1 = {<text variable, no debug info>} 0x7ffff7ed66c0 <arg>

Explanation:
Breakpoints 1 and 2 (notifier_free and notifier_reuse) show arg=0x0. Nothing has been corrupted yet; memory is still clean.
Breakpoint 3 (mq_notify) shows arg=0x7ffff7ed66c0 <arg> — suddenly arg is non-null. This is the dangling pointer being reused after free.
At this moment, the struct pointed to by arg is in an invalid/corrupted state. You can see this if you try to p *(struct sigevent *)arg — the values are nonsensical (<text variable, no debug info>).
The segfault in pthread_attr_destroy() happens later because some internal library code tries to use memory that has already been corrupted or freed. That crash is a consequence, not the trigger itself.


9 - If you keep stepping until you see pthread_attr_destroy is called, you will get the following error:
--- mq_notify called ---
Cannot access memory at address 0x7ffff7ed66c0


10 - To quit gdb and then docker insert: "quit" then "exit"

== Running Patched version ==

1 - In your own machine's environment, simply compile with: gcc -g -O0 -pthread vulnerability_example.c -o vuln -lrt
And run : ./vuln

You will see the program simply hang/freeze instead of outright crashing.
