In order to run 'vulnerability_examle' you must do it in a docker container, with glibc 2.32 or 2.33

How to safely run the exploit:

1 - Open Docker Desktop
2 - In wsl terminal insert: docker run --privileged -it \-v "/mnt/c/Users/User/Desktop/Universidade/Pesquisa AI-SSD/vulnerabilities/CVE-2021-33574_CWE-416:/mnt/code" \cve-2021-33574_cwe-416_image

If it takes too long, cancel, restart docker, and try again. The terminal should look like this:

billy@LAPTOP-QH206F1H:/mnt/c/Users/User/Desktop/Universidade/Pesquisa AI-SSD/vulnerabilities/CVE-2021-33574_CWE-416$ docker run -it cve-2021-33574_cwe-416_image
[root@56b80ca79b29 /]# 

Then insert: 
to disable ASLR
 - echo 0 > /proc/sys/kernel/randomize_va_space

to go to where the code is
 - cd mnt/code/

if you then insert ls, you should see the code file 'vulnerability_example.c'

3 - Check glibc version with: ldd --version
The following message should appear:

ldd (GNU libc) 2.32  //(or 2.33)
Copyright (C) 2020 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
Written by Roland McGrath and Ulrich Drepper.

4 - Compile with: gcc -fsanitize=address -g -O1 -pthread -o vuln vulnerability_example.c -lrt
Run with: for i in {1..10}; do echo "Run #$i"; ./vuln; done


5 - To quit docker insert: exit

NOTE:
the vulnerability is non-deterministic and requires:

    Perfect timing

    Thread interleaving during mq_notify unregister/register

    Possibly multiple runs to trigger

================================================================================================================================================================================================================================

Perfect ‚Äî let‚Äôs walk through the **steps** to replicate **CVE-2021-33574** without spoiling the whole solution. You‚Äôll be building a small C program to demonstrate the **use-after-free** in `mq_notify()` with `SIGEV_THREAD`.

---

## üõ†Ô∏è Steps to Replicate CVE-2021-33574

### ‚úÖ 1. **Set up a glibc version that is vulnerable**

* Use glibc **2.32 or 2.33** (you‚Äôve already done this using Docker ‚Äî great!)
* Confirm with `ldd --version`

---

### ‚úÖ 2. **Create a POSIX message queue**

* Use `mq_open()` to create a new message queue.
* Set appropriate flags (`O_CREAT | O_RDWR`) and permissions.

---

### ‚úÖ 3. **Define a `struct sigevent`**

* Use `SIGEV_THREAD` as the notification method.
* Provide:

  * A function pointer (`sigev_notify_function`)
  * A `sigev_value` (optional context)
  * Possibly `sigev_notify_attributes` (thread attributes)

---

### ‚úÖ 4. **Pass the `sigevent` to `mq_notify()`**

* Call `mq_notify(mqd, &sev);`

---

### ‚úÖ 5. **Free the memory (or let it go out of scope)**

* Either:

  * Allocate `sev` or its attributes dynamically and `free()` them
  * Or define `sev` on the stack and exit the defining scope

---

### ‚úÖ 6. **Trigger the notification**

* Send a message to the queue using `mq_send()`
* This causes glibc to try using the now-invalid memory (use-after-free)

---

### ‚úÖ 7. **Observe the crash or unexpected behavior**

* You might see:

  * Segmentation fault
  * Corrupted function calls
  * Silent memory corruption (needs `gdb` to catch)

---

Let me know when you‚Äôve reached a step or want help validating that you‚Äôre triggering the bug correctly. Want to begin with message queue setup?
